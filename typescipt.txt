type PostProps = {
    id: number,
    title:string,
    message?: string,
    toggle: boolean,
    extra: "closed" | "open"

}[] // make it an array of objects

export defaut function Post({id, title, message} : PostProps)

########################## new file ###########################

async function getPosts(): Promise<TheseProps> {
    yada yada
}

export defaut async function Home(){
    const data = await getPosts() // will be type TheseProps
    return(
        <>
        <Post  /> //type PostProps with warn that they are needed 
        </>  
    )
}

##########################

type ChildProps = {
    children: React.ReactNode
}

export default function NewPage ({children}: ChildProps) {

}

#################

(e: React.MouseEvent)

################################################ Generics ####################################


function getFirst(array: (number|string)[]){} //example
function getFirst(array: any[]){} //example

function getFirst<ElementType>(array: ElementType[]){
    return array[0]
}

const thisIsATypeNumber getFirst<number>([1,3,4])

const otherMap = new Map<string,Map<string, number>>()

const map = new Map<string,number>()
map.set("dfasdf",3)



type ApiRes<Data extends object = {status: number}> = { // must adhear to object and makes a default if no generic is passed in
    data: Data
    isError: boolean
}

const response: ApiRes <{name:string; age:number}> = {
    data: {
        name: "Kevin",
        age: 36
    },
    isError: flase
}


type ArticleRes = ApiRes<{title:string; content:string}>
type favoriteNumber = ApiRes<{favNum:number}>

const article: ArticleRes = {
    data: {
        title: "aasdf",
        content: "asdfasdf"
    },
    isError: flase
}

const coolnumber: favoriteNumber = {
    data: {
        favNum: 4
    },
    isError: false
}



great array methods

Object.groupBy([]) //array of object

newArray with index 3 having value 6 = array.with(3, 6)

array.(at) // allows negiative numbers

.fill(2)// mutates original aray to be filled with one 

.toSorted .toRevsered .toSpliced // does not mutate and returns new array // without to mutates


array.flat(Number.POSITIVE_INFINITY) // destructures and array of arrys into an aray of elements

array.flatmap() //flattens and then maps over

.findlast()

Array.isArray([dsf,sdfg,sdfg])